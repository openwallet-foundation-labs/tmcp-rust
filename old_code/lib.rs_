//! # TMCP - Transport Extensions for Model Context Protocol
//!
//! This crate provides transport layer extensions and utilities for the Model Context Protocol (MCP).
//! It builds upon the core `rmcp` crate to offer additional transport mechanisms and helpers.

#![warn(missing_docs)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use anyhow::{Result, anyhow};
use log::{debug, error, info};
use serde::{Deserialize, Serialize};
use serde_json;
use tsp_sdk::{Error, ReceivedTspMessage, vid::{VidError, verify_vid}};
use std::sync::Arc;
use base64::{engine::general_purpose, Engine as _};


// Real TSP SDK types
pub use tsp_sdk::{AskarSecureStorage, AsyncSecureStore, SecureStorage, OwnedVid, Vid, VerifiedVid};

/// TSP Wallet structure matching the real TSP SDK implementation
pub struct TspWallet {
    pub db: tsp_sdk::AsyncSecureStore,
}

impl std::fmt::Debug for TspWallet {
/// Format a `TspWallet` instance using the given formatter.
///
/// The formatted output will be a debug representation of the `TspWallet`
/// instance, containing its public fields.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TspWallet").finish()
    }
}

pub use rmcp;

use futures::{StreamExt, stream::BoxStream};
use reqwest::header::CONTENT_TYPE;
use rmcp::{
    model::{ClientJsonRpcMessage, ServerJsonRpcMessage},
    transport::streamable_http_client::{
        SseError, StreamableHttpClient, StreamableHttpError, StreamableHttpPostResponse,
    },
};
use sse_stream::{Sse, SseStream};

#[derive(Clone)]
pub struct MyHttpClient {
    inner: reqwest::Client,
    transport_hook: Option<Arc<TmcpTransportHook>>,
}

/// Error types for MyHttpClient operations
#[derive(Debug, thiserror::Error)]
pub enum MyHttpClientError {
    /// Error from reqwest HTTP client
    #[error("Reqwest error: {0}")]
    Reqwest(#[from] reqwest::Error),
    /// Error from JSON serialization/deserialization
    #[error("Serde JSON error: {0}")]
    SerdeJson(#[from] serde_json::Error),
    /// Error from invalid HTTP header value
    #[error("Invalid header value: {0}")]
    InvalidHeaderValue(#[from] reqwest::header::InvalidHeaderValue),
}

impl MyHttpClient {
    /// Create a new MyHttpClient with default reqwest client
    pub fn new() -> Self {
        Self {
            inner: reqwest::Client::new(),
            transport_hook: None,
        }
    }

    /// Create a new MyHttpClient with a transport hook for TSP functionality
    pub fn with_transport_hook(transport_hook: Arc<TmcpTransportHook>) -> Self {
        Self {
            inner: reqwest::Client::new(),
            transport_hook: Some(transport_hook),
        }
    }

    /// Create a new MyHttpClient with custom reqwest client and transport hook
    pub fn with_client_and_hook(
        client: reqwest::Client,
        transport_hook: Option<Arc<TmcpTransportHook>>,
    ) -> Self {
        Self {
            inner: client,
            transport_hook,
        }
    }
}

impl StreamableHttpClient for MyHttpClient {
    type Error = MyHttpClientError;

    async fn post_message(
        &self,
        uri: Arc<str>,
        message: ClientJsonRpcMessage,
        session_id: Option<Arc<str>>,
        auth_token: Option<String>,
    ) -> Result<StreamableHttpPostResponse, StreamableHttpError<Self::Error>> {
        use reqwest::header::ACCEPT;
        use rmcp::transport::common::http_header::{
            EVENT_STREAM_MIME_TYPE, HEADER_SESSION_ID, JSON_MIME_TYPE,
        };
        // Apply TSP seal_message transformation if transport hook is available
        let message_to_send = if let Some(hook) = &self.transport_hook {
            let json_str =
                serde_json::to_string(&message).map_err(|e| StreamableHttpError::Deserialize(e))?;
            println!("json_str: {}", json_str);
            // Use the transport hook to seal the message
            let sealed_data = hook.seal_message(json_str);
            let sealed_data = match sealed_data {
                Ok(s) => s,
                Err(e) => {
                    tracing::error!("failed to seal message: {}", e);
                    "".to_string()
                }
            };
            // Try to parse the sealed data back to a message, or use raw body
            match serde_json::from_str::<ClientJsonRpcMessage>(&sealed_data) {
                Ok(sealed_message) => sealed_message,
                Err(_) => {
                    // If sealed data is not valid JSON, we need to send it as raw body
                    let mut request = self
                        .inner
                        .post(uri.as_ref())
                        .header(ACCEPT, [EVENT_STREAM_MIME_TYPE, JSON_MIME_TYPE].join(", "))
                        .header(CONTENT_TYPE, JSON_MIME_TYPE)
                        .body(sealed_data);

                    if let Some(auth_header) = auth_token {
                        request = request.bearer_auth(auth_header);
                    }
                    if let Some(session_id) = session_id {
                        request = request.header(HEADER_SESSION_ID, session_id.as_ref());
                    }

                    let response = request
                        .send()
                        .await
                        .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

                    return self.handle_response(response).await;
                }
            }
        } else {
            message
        };

        // Standard JSON request path
        let mut request = self
            .inner
            .post(uri.as_ref())
            .header(ACCEPT, [EVENT_STREAM_MIME_TYPE, JSON_MIME_TYPE].join(", "));

        if let Some(auth_header) = auth_token {
            request = request.bearer_auth(auth_header);
        }
        if let Some(session_id) = session_id {
            request = request.header(HEADER_SESSION_ID, session_id.as_ref());
        }

        let response = request
            .json(&message_to_send)
            .send()
            .await
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

        self.handle_response(response).await
    }

    async fn delete_session(
        &self,
        uri: Arc<str>,
        session_id: Arc<str>,
        auth_token: Option<String>,
    ) -> Result<(), StreamableHttpError<Self::Error>> {
        use rmcp::transport::common::http_header::HEADER_SESSION_ID;

        let mut request_builder = self.inner.delete(uri.as_ref());
        if let Some(auth_header) = auth_token {
            request_builder = request_builder.bearer_auth(auth_header);
        }
        let response = request_builder
            .header(HEADER_SESSION_ID, session_id.as_ref())
            .send()
            .await
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

        if response.status() == reqwest::StatusCode::METHOD_NOT_ALLOWED {
            tracing::debug!("this server doesn't support deleting session");
            return Ok(());
        }
        let _response = response
            .error_for_status()
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;
        Ok(())
    }

    async fn get_stream(
        &self,
        uri: Arc<str>,
        session_id: Arc<str>,
        last_event_id: Option<String>,
        auth_token: Option<String>,
    ) -> Result<BoxStream<'static, Result<Sse, SseError>>, StreamableHttpError<Self::Error>> {
        use reqwest::header::ACCEPT;
        use rmcp::transport::common::http_header::{
            EVENT_STREAM_MIME_TYPE, HEADER_LAST_EVENT_ID, HEADER_SESSION_ID, JSON_MIME_TYPE,
        };

        let mut request_builder = self
            .inner
            .get(uri.as_ref())
            .header(ACCEPT, [EVENT_STREAM_MIME_TYPE, JSON_MIME_TYPE].join(", "))
            .header(HEADER_SESSION_ID, session_id.as_ref());
        if let Some(last_event_id) = last_event_id {
            request_builder = request_builder.header(HEADER_LAST_EVENT_ID, last_event_id);
        }
        if let Some(auth_header) = auth_token {
            request_builder = request_builder.bearer_auth(auth_header);
        }
        let response = request_builder
            .send()
            .await
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

        if response.status() == reqwest::StatusCode::METHOD_NOT_ALLOWED {
            return Err(StreamableHttpError::ServerDoesNotSupportSse);
        }
        let response = response
            .error_for_status()
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;
        match response.headers().get(reqwest::header::CONTENT_TYPE) {
            Some(ct) => {
                if !ct.as_bytes().starts_with(EVENT_STREAM_MIME_TYPE.as_bytes())
                    && !ct.as_bytes().starts_with(JSON_MIME_TYPE.as_bytes())
                {
                    return Err(StreamableHttpError::UnexpectedContentType(Some(
                        String::from_utf8_lossy(ct.as_bytes()).to_string(),
                    )));
                }
            }
            None => {
                return Err(StreamableHttpError::UnexpectedContentType(None));
            }
        }

        let event_stream = SseStream::from_byte_stream(response.bytes_stream());

        // Apply TSP open_message transformation if transport hook is available
        if let Some(hook) = &self.transport_hook {
            let hook_clone = hook.clone();
            let wrapped_stream = event_stream.map(move |result| {
                result.map(|mut sse| {
                    if let Some(data) = sse.data.take() {
                        let processed_data = hook_clone.open_message(data);
                        match processed_data {
                            Ok(processed_data) => {
                                sse.data = Some(processed_data);
                            }
                            Err(e) => {
                                tracing::error!("failed to open message: {}", e);
                            }
                        }
                    }
                    sse
                })
            });
            Ok(wrapped_stream.boxed())
        } else {
            Ok(event_stream.boxed())
        }
    }
}

impl MyHttpClient {
    /// Handle HTTP response and apply TSP transformations
    async fn handle_response(
        &self,
        response: reqwest::Response,
    ) -> Result<StreamableHttpPostResponse, StreamableHttpError<MyHttpClientError>> {
        use http::header::WWW_AUTHENTICATE;
        use rmcp::transport::common::http_header::{
            EVENT_STREAM_MIME_TYPE, HEADER_SESSION_ID, JSON_MIME_TYPE,
        };
        use std::borrow::Cow;

        if response.status() == reqwest::StatusCode::UNAUTHORIZED {
            if let Some(header) = response.headers().get(WWW_AUTHENTICATE) {
                let header = header
                    .to_str()
                    .map_err(|_| {
                        StreamableHttpError::UnexpectedServerResponse(Cow::from(
                            "invalid www-authenticate header value",
                        ))
                    })?
                    .to_string();
                return Err(StreamableHttpError::AuthRequired(
                    rmcp::transport::streamable_http_client::AuthRequiredError {
                        www_authenticate_header: header,
                    },
                ));
            }
        }

        let status = response.status();
        let response = response
            .error_for_status()
            .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

        if matches!(
            status,
            reqwest::StatusCode::ACCEPTED | reqwest::StatusCode::NO_CONTENT
        ) {
            return Ok(StreamableHttpPostResponse::Accepted);
        }

        let content_type = response.headers().get(reqwest::header::CONTENT_TYPE);
        let session_id = response.headers().get(HEADER_SESSION_ID);
        let session_id = session_id
            .and_then(|v| v.to_str().ok())
            .map(|s| s.to_string());

        match content_type {
            Some(ct) if ct.as_bytes().starts_with(EVENT_STREAM_MIME_TYPE.as_bytes()) => {
                let event_stream = SseStream::from_byte_stream(response.bytes_stream());

                // Apply TSP open_message transformation to SSE stream if available
                if let Some(hook) = &self.transport_hook {
                    let hook_clone = hook.clone();
                    let wrapped_stream = event_stream.map(move |result| {
                        result.map(|mut sse| {
                            if let Some(data) = sse.data.take() {
                                let processed_data = hook_clone.open_message(data);
                                match processed_data {
                                    Ok(processed_data) => {
                                        sse.data = Some(processed_data);
                                    }
                                    Err(e) => {
                                        tracing::error!("failed to open message: {}", e);
                                    }
                                }
                            }
                            sse
                        })
                    });
                    Ok(StreamableHttpPostResponse::Sse(
                        wrapped_stream.boxed(),
                        session_id,
                    ))
                } else {
                    Ok(StreamableHttpPostResponse::Sse(
                        event_stream.boxed(),
                        session_id,
                    ))
                }
            }
            Some(ct) if ct.as_bytes().starts_with(JSON_MIME_TYPE.as_bytes()) => {
                let body = response
                    .text()
                    .await
                    .map_err(|e| StreamableHttpError::Client(MyHttpClientError::Reqwest(e)))?;

                // Apply TSP open_message transformation if available
                println!("open_message instance 2 - Apply TSP open_message");
                let processed_body = self.transport_hook
                    .as_ref()
                    .map(|hook| hook.open_message(body.clone()).unwrap_or_else(|e| {
                        tracing::error!("failed to open message: {}", e);
                        String::new()
                    }))
                    .unwrap_or(body);

                let message: ServerJsonRpcMessage = serde_json::from_str(&processed_body)
                    .map_err(|e| StreamableHttpError::Deserialize(e))?;
                Ok(StreamableHttpPostResponse::Json(message, session_id))
            }
            _ => {
                tracing::error!("unexpected content type: {:?}", content_type);
                Err(StreamableHttpError::UnexpectedContentType(
                    content_type.map(|ct| String::from_utf8_lossy(ct.as_bytes()).to_string()),
                ))
            }
        }
    }
}

impl Default for MyHttpClient {
    fn default() -> Self {
        Self::new()
    }
}

/// Convenience methods for creating TMCP transports
impl MyHttpClient {
    /// Create a StreamableHttpClientTransport using MyHttpClient with TSP support
    pub fn create_transport(
        &self,
        uri: impl Into<Arc<str>>,
    ) -> rmcp::transport::StreamableHttpClientTransport<Self> {
        use rmcp::transport::streamable_http_client::{
            StreamableHttpClientTransport, StreamableHttpClientTransportConfig,
        };
        let did = if let Some(hook) = &self.transport_hook {
            hook.my_did.clone()
        } else {
            "".to_string()
        };
        let config = StreamableHttpClientTransportConfig::with_uri(format!("{}?did={}", uri.into(), did));
    
        StreamableHttpClientTransport::with_client(self.clone(), config)
    }
}

/// TMCP general settings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TmcpSettings {
    /// DID publish URL
    pub did_publish_url: String,
    /// DID publish history URL template
    pub did_publish_history_url: String,
    /// DID web format template
    pub did_web_format: String,
    /// DID webvh format template
    pub did_webvh_format: String,
    /// Transport protocol prefix
    pub transport: String,
    /// Whether TSP messages should be printed
    pub verbose: bool,
    /// Wallet URL for secure storage
    pub wallet_url: String,
    /// Wallet password
    pub wallet_password: String,
    /// Whether to use webvh DIDs
    pub use_webvh: bool,
    /// DID server address
    pub did_server: String,
}

impl Default for TmcpSettings {
    /*************  ✨ Windsurf Command ⭐  *************/
    /// Returns a default TmcpSettings configuration with the following settings:
    ///
    /// * did_publish_url: https://did.teaspoon.world/add-vid
    /// * did_publish_history_url: https://did.teaspoon.world/add-history/{did}
    /// * did_web_format: did:web:did.teaspoon.world:endpoint:{name}
    /// * did_webvh_format: did.teaspoon.world/endpoint/{name}
    /// * transport: tmcp://
    /// * verbose: true
    /// * wallet_url: sqlite://wallet.sqlite
    /// * wallet_password: unsecure
    /// * use_webvh: true
    /*******  e8082e7b-9eab-4f44-a17e-6a86ab880b84  *******/
    fn default() -> Self {
        Self {
            did_publish_url: "https://did.teaspoon.world/add-vid".to_string(),
            did_publish_history_url: "https://did.teaspoon.world/add-history/{did}".to_string(),
            did_web_format: "did:web:did.teaspoon.world:endpoint:{name}".to_string(),
            did_webvh_format: "did.teaspoon.world/endpoint/{name}".to_string(),
            transport: "tmcp://".to_string(),
            verbose: true,
            wallet_url: "sqlite://wallet.sqlite".to_string(),
            wallet_password: "unsecure".to_string(),
            use_webvh: true,
            did_server: "did.teaspoon.world".to_string(),
        }
    }
}

/// TMCP Transport Manager
#[derive(Default)]
pub struct TmcpManager {
    /// TMCP settings configuration
    pub settings: TmcpSettings,
    /// Decentralized identifier for this manager
    pub did: String,
    /// TSP Wallet for secure storage
    pub wallet: Option<TspWallet>,
}

impl TmcpManager {
    /// Create a new TMCP manager with the given alias and settings
    pub async fn new(alias: &str, settings: Option<TmcpSettings>) -> Result<Self> {
        let settings = settings.unwrap_or_default();

        // Initialize identity (simplified version - would need TSP library integration)
        let (did, wallet) = match Self::init_identity(alias, &settings).await {
            Ok(result) => result,
            Err(e) => {
                eprintln!("Failed to initialize identity: {}", e);
                std::process::exit(1);
            }
        };

        Ok(Self { settings, did, wallet: Some(wallet) })
    }

    /// Initialize DID identity (simplified implementation)
    async fn init_identity(alias: &str, settings: &TmcpSettings) -> Result<(String, TspWallet)> {
        println!("settings: {:?}", settings);
        
        // Create AskarSecureStorage instance
        let storage = tsp_sdk::AskarSecureStorage::open(&settings.wallet_url, settings.wallet_password.as_bytes()).await?;
        // Simplified DID creation - in real implementation would use TSP library
        println!("Initializing identity for alias: {}", alias);
        let wallet_alias = if settings.use_webvh {
            format!("{}vh", alias)
        } else {
            alias.to_string()
        };

        // Note: In a real implementation, this would:
        // 1. Create TSP identity using tsp_rust crate
        // 2. Publish DID to the network
        // 3. Store in secure wallet
        let (vids, aliases, keys) = storage.read().await?;
        println!("vids:, aliases: {:?}", aliases);
        let db = AsyncSecureStore::new();
        db.import(vids, aliases, keys)?;
        let mut did: Option<String> = db.resolve_alias(&wallet_alias)?;
        println!("Initialized DID: {:?}, print {:?}", did, wallet_alias);
        let mut is_new_did = false;
        let setting = settings.clone();
        if let Some(did_str) = &did {
            if (settings.use_webvh && !did_str.starts_with("did:webvh:")) || (!settings.use_webvh && !did_str.starts_with("did:web:")) {
                did = None;
                is_new_did = true;
            } else {
                // async fn vid_verify(did_str: &String, db: &AsyncSecureStore, alias: &str, endpoint: &str, settings: &TmcpSettings) -> Result<bool> {
                //     let (vid, metadata) = tsp_sdk::vid::verify_vid(did_str).await?;
                //     let endpoint = vid.endpoint().to_string();
                //     db.add_verified_vid(vid, metadata)?;
                //     db.set_alias(did_str.to_string(), alias.to_string())?;
                //     Ok(endpoint == settings.transport)
                // }
                // match vid_verify(did_str, &db, &wallet_alias, &settings.transport, settings).await {
                //     Ok(valid) => {
                //         if valid {
                //             println!("Using existing DID: {}", did_str);
                //             return Ok((did_str.clone(), TspWallet { db }));
                //         } else {
                //             println!("Existing DID endpoint mismatch, creating new DID");
                //         }
                //     }
                //     Err(e) => {
                //         println!("Failed to verify existing DID: {}, creating new DID", e);
                //     }
                // }
            }
        }
        return Ok((did.unwrap_or_default(), TspWallet { db }));
        let mut did = did.unwrap_or_default();
        let (private_vid, history) = if settings.use_webvh{
            let transport= settings.transport.clone();
            let url = url::Url::parse(&transport)?;
            let did_server = &settings.did_server;
            //did_server: did.teaspoon.world username: tom transport: https://p.teaspoon.world/endpoint/[vid_placeholder]
            let username = did.split(':').last().unwrap_or(alias);
            let did_path = settings.did_webvh_format.replace("{name}", &username);
            let (private_vid, history, update_kid, update_key) = tsp_sdk::vid::did::webvh::create_webvh(&did_path, url).await?;
            println!("Created WebVH VID: {:?}", private_vid.vid());
            did = private_vid.identifier().to_string();
            db.add_secret_key(update_kid, update_key)?;
            let client = reqwest::Client::new();
            let _ = match client
                .post(format!("https://{did_server}/add-vid"))
                .json(&private_vid.vid())
                .send()
                .await
                .inspect(|r| debug!("DID server responded with status code {}", r.status()))
                .expect("Could not publish VID on server")
                .error_for_status()
            {
                Ok(response) => {response.json::<Vid>().await.expect("Could not decode VID");},
                Err(e) => {
                    // error!(
                    //     "{e}\nAn error occurred while publishing the DID. Maybe this DID exists already?"
                    // );
                    // return Err(anyhow!("An error occurred while publishing the DID. Maybe this DID exists already?"));
                }
            };
            info!(
                "published DID document at {}",
                tsp_sdk::vid::did::get_resolve_url(private_vid.vid().identifier())?
                    .to_string()
            );
            
            match client
                .post(format!(
                    "https://{did_server}/add-history/{}",
                    private_vid.vid().identifier()
                ))
                .json(&history)
                .send()
                .await
                .inspect(|r| debug!("DID server responded with status code {}", r.status()))
                .expect("Could not publish history on server")
                .error_for_status()
            {
                Ok(_) => {}
                Err(e) => {
                    // error!(
                    //     "{e}\nAn error occurred while publishing the DID. Maybe this DID exists already?"
                    // );
                    // return Err(anyhow!("An error occurred while publishing the DID. Maybe this DID exists already?"));
                }
            };
            (private_vid, Some(serde_json::to_string(&history)?))
        } else {
            (tsp_sdk::OwnedVid::bind(
                did.clone(),
                url::Url::parse(&settings.transport)?,
            ), None)
        };
        //did = identity.identifier().to_string();
        
        // Create HTTP client
        
        let identity_json = serde_json::to_string(&private_vid.vid())?;
        println!("identity_json: {}", identity_json);
  
        println!("before verify_vid {:?}", did.clone());
        let (_, metadata) = verify_vid(&did)
            .await
            .map_err(|err| Error::Vid(VidError::InvalidVid(err.to_string())))?;
        println!("identity verified metadata: {:?}, identity: {:?}", metadata, private_vid);
        db.add_private_vid(private_vid, metadata)?;
        println!("Published client DID: {}", did);

        Ok((did, TspWallet { db }))
    }

    /// Get the DID for this manager
    pub fn did(&self) -> &str {
        &self.did
    }

    /// Retrieve data from wallet by key
    pub fn retrieve_from_wallet(&self, _key: &str) -> Result<Vec<u8>> {
        // Simplified implementation - would use actual wallet storage
        Err(anyhow!("Wallet operations not implemented"))
    }
}

// Remove the mock TSP message structures since we'll use real TSP-SDK

/// TMCP Transport Hook for message encryption/decryption using TSP functions
#[derive(Default)]
pub struct TmcpTransportHook {
    my_did: String,
    other_did: String,
    verbose: bool,
    /// TSP secure storage for cryptographic operations
    secure_store: Option<TspWallet>,
}

impl TmcpTransportHook {
    /// Create a new TMCP transport hook, reading my_did from the wallet
    pub fn new(my_did: String, other_did: String, wallet: Option<TspWallet>, verbose: bool) -> Self {
        log::info!("Initializing TMCP hook");

        Self {
            my_did,
            other_did,
            verbose,
            secure_store: wallet, // Will be initialized when needed
        }
    }
    /// Set the secure store for TSP operations
    pub fn with_secure_store(mut self, store: TspWallet) -> Self {
        self.secure_store = Some(store);
        self
    }
}

impl TmcpTransportHook {
    fn open_message(&self, data: String) -> anyhow::Result<String> {
        println!("open_message data: {} length: {}", data, data.len());
        let mut data = general_purpose::URL_SAFE.decode(&data)?;
        //println!("after decoding data: {}", String::from_utf8(data.clone())?); //data);
        //let mut data = Base64::decode_vec(&data)?;
        let Some(wallet) = &self.secure_store else {
            log::warn!("No TSP wallet available, returning original message");
            return Ok(String::new());
        };
        let (sender, receiver) = tsp_sdk::cesr::get_sender_receiver(&data)?;
        let tsp_message = wallet.db.open_message(&mut data)?;
        if let ReceivedTspMessage::GenericMessage{
            message,..
        } = tsp_message {
            Ok(String::from_utf8(message.to_vec())?)
        } else {
            Err(anyhow!("Unsupported TSP message type"))
        }
    }

    fn seal_message(&self, data: String) -> anyhow::Result<String> {
        
        if self.verbose {
            log::info!(
                "TSP sealing message from {} to {} ({} bytes)",
                self.my_did,
                self.other_did,
                data.len()
            );
        }
        let Some(wallet) = &self.secure_store else {
            log::warn!("No TSP wallet available, returning original message");
            return Ok(String::new());
        };
        let (url, data) = wallet.db.seal_message(&self.my_did, &self.other_did, None, &data.into_bytes())?;
        let (sender, receiver) = tsp_sdk::cesr::get_sender_receiver(&data)?;
        Ok(general_purpose::URL_SAFE.encode(&data))
    }
}

fn ensure_vid_verified(vid_wallet: &AsyncSecureStore, receiver_vid: &str) -> anyhow::Result<bool> {
    Ok(vid_wallet.has_verified_vid(receiver_vid)?)
}
